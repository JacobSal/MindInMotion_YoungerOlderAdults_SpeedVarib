---
title: "Linear Mixed Effects Models for Kin & Speed Predictors for EEG"
author: "Jacob Salminen"
date: \`r format(Sys.Date(),"%d-%m-%Y")`\
output:
  html_document:
    theme: flatly
    toc: true
    toc_depth: 6
    toc_float:
      collapsed: false
      smooth_scroll: true
    df_print: paged
# runtime: shiny
---

```{r setup, include=FALSE}
# ERROR. png() device not found bug try: dev.off()
# ERROR. png() device not found fixed by changing cell names to a simple "windows friendlY" format so that knitr could save files.
knitr::opts_chunk$set(echo = TRUE)
```

# Packages & Setup
```{r}
# install.packages(c("tidyverse","purrr","R.matlab","readxl","dplyr"))
library(readxl);
library(purrr);
library(tidyverse);
library(tibble);
library(knitr);
library(gtsummary);
library(kableExtra);
library(lme4);
library(MuMIn);
# library(effects);
library(sjPlot);
# library(rgl);
library(plotly);
library(webshot)
library(reshape2);
library(htmltools)
library(Polychrome);
library(plotly)
library(htmlwidgets);
library(shiny)
# library(listviewer);
```

## GTSUMMARY THEME
``` {r}
gtsummary::set_gtsummary_theme(theme_gtsummary_journal("jama"))
```

## load table 
```{r} 
# excel_dir <-"M://GitHub/par_EEGProcessing/src/_data/MIM_dataset/_studies/04162024_MIM_YAOAN89_antsnormalize_iccREMG0p4_powpow0p3_skull0p01/cluster/icrej_5/12/spec_data/group_spec/psd_calcs/fooof_kinematics_table.xlsx";
# excel_dir <-"M:/jsalminen/GitHub/par_EEGProcessing/src/_data/MIM_dataset/_studies/04232024_MIM_YAOAN89_antsnorm_dipfix_iccREMG0p4_powpow0p3_skull0p01_15mmrej/cluster/icrej_5/11/spec_data/group_spec/psd_calcs/fooof_kinematics_table_nans.xlsx";
excel_dir <-"M:/jsalminen/GitHub/par_EEGProcessing/src/_data/MIM_dataset/_studies/04232024_MIM_YAOAN89_antsnorm_dipfix_iccREMG0p4_powpow0p3_skull0p01_15mmrej/iclabel_cluster_kmeansalt_rb3/icrej_5/11/psd_calcs/group_spec/kin_tests/fooof_kinematics_table.xlsx";
orig_eegt <- read_excel(excel_dir,sheet="Sheet1") 
```

## get unique entries 
```{r} 

#%% KIN PARAMS
# kin_measures = c('mean_APexc_COV','mean_APexc_mean','mean_MLexc_COV','mean_MLexc_mean','mean_StepDur','mean_StepDur_cov','mean_UDexc_COV','mean_UDexc_mean','mean_StanceDur','mean_GaitCycleDur','mean_PeakUpDownVel_mean');
# kin_title_chars = c("AP Exc. COV","AP Exc. Mean","ML Exc. COV","ML Exc. Mean","Step Dur.","Step Dur. COV","UD Exc. COV","UD Exc Mean","Stance Dur.","Gait Cycle Dur.","Peak UD Vel. Mean")
# kin_measures = c('mean_APexc_COV','mean_MLexc_COV','mean_StepDur_cov','mean_StanceDur');
# kin_title_chars = c("AP Exc. COV","ML Exc. COV","Step Dur. COV","Stance Dur.")
kin_measures = c('mean_APexc_COV','mean_MLexc_COV');
kin_title_chars = c("AP Exc. COV","ML Exc. COV")
kin_inds_plot = c(1:length(kin_measures));
# kin_inds_plot = c(1,3,6,5,7);
#%% EEG PARAMS
clusters = unique(orig_eegt$cluster_id);
subjects = unique(orig_eegt$subj_char);
groups = unique(orig_eegt$group_char);
# eeg_measures = c('theta_avg_power','alpha_avg_power','beta_avg_power','beta_div_theta','theta_div_beta','log_beta_div_theta','log_theta_div_beta','aperiodic_exp','aperiodic_offset');
# eeg_title_chars = c("**THETA**","**ALPHA**","**BETA**","**BETA/THETA**","**THETA/BETA**","**log10(BETA/THETA)**","**log10(THETA/BETA)**","**AP exp**","**AP offset**");
# eeg_measures = c('theta_avg_power','alpha_avg_power','beta_avg_power','aperiodic_exp','aperiodic_offset');
# eeg_measures = c('norm_theta_avg_power','norm_alpha_avg_power','norm_beta_avg_power');
eeg_measures = c('norm_theta_avg_power','norm_alpha_avg_power','norm_beta_avg_power');
eeg_title_chars = c("**THETA**","**ALPHA**","**BETA**");
# eeg_inds_plot = c(1:length(eeg_title_chars));
eeg_inds_plot = c(1,3);
x_vals_plot = c('speed_diffdiv_stat')
x_vals_labs = c("**(Trial-Subj.)/(Subj.)**")
cluster_inds_plot = c(3,4,5,6,7,8,12);
# cluster_inds_plot = c(3,4,5);
```

## create ratios
```{r}
df <- orig_eegt %>%
  select(subj_char,cond_char,cluster_id,group_id,alpha_avg_power,beta_avg_power,theta_avg_power) %>%
  pivot_wider(names_from = "cond_char", names_sep = '.', values_from = c(alpha_avg_power,beta_avg_power,theta_avg_power))

# df <- df %>%
#   group_by(subj_char) %>%
#   mutate(across(starts_with("alpha_avg_power"), ~ .x/alpha_avg_power.flat))
# df <- df %>%
#   group_by(subj_char) %>%
#   mutate(across(starts_with("beta_avg_power"), ~ .x/beta_avg_power.flat))
# df <- df %>%
#   group_by(subj_char) %>%
#   mutate(across(starts_with("theta_avg_power"), ~ .x/theta_avg_power.flat))
df <- df %>%
  group_by(subj_char) %>%
  mutate(across(starts_with("alpha_avg_power"), ~ .x-alpha_avg_power.flat))
df <- df %>%
  group_by(subj_char) %>%
  mutate(across(starts_with("beta_avg_power"), ~ .x-beta_avg_power.flat))
df <- df %>%
  group_by(subj_char) %>%
  mutate(across(starts_with("theta_avg_power"), ~ .x-theta_avg_power.flat))

df <- df %>%
  pivot_longer(cols = starts_with(c("alpha","beta","theta")), names_to = c(".value","cond_char"), names_pattern = "(.*_power).(.*)");

df$norm_alpha_avg_power <- df$alpha_avg_power
df$norm_beta_avg_power <- df$beta_avg_power
df$norm_theta_avg_power <- df$theta_avg_power
df <- select(df,-alpha_avg_power,-beta_avg_power,-theta_avg_power);
eegt <- merge(orig_eegt , df, by.x = c("subj_char","cond_char","cluster_id","group_id"), by.y = c("subj_char","cond_char","cluster_id","group_id"));
```
## get speeds only 
```{r}
eegt <- filter_at(eegt,vars('cond_char'), any_vars(. %in% c('0.25','0.5','0.75','1.0')))
flat_speeds = unique(eegt$cond_char)
eegt$speed_cond_num <- as.numeric(eegt$speed_diffdiv_stat); #as.numeric(eegt$cond_char)
eegt <- mutate(eegt,across(c('subj_char'), factor))
eegt <- mutate(eegt,across(c('group_char'), factor))
head(eegt)
color_pal_group = as.vector(createPalette(length(levels(eegt$group_char)),c("#0000ff")));
```

# MODERATION 1.a) LME EEG ~ 1+kin+speed+kin:speed

```{r eegkinspeedinterspeed, echo=FALSE, message=FALSE, results="asis"}
suppressWarnings({
  suppressMessages({
    library(plotly)
    library(htmltools)
    })})
l <- htmltools::tagList()
# app_urls <- c()
cnt = 1;
for (ci in cluster_inds_plot) {
  tmpt <- filter_at(eegt,vars('cluster_id'), any_vars(. %in% ci));
  for(ki in kin_inds_plot){
    tmpt = tmpt[complete.cases(tmpt[[kin_measures[ki]]]),]
  }
  for (mi in 1:length(kin_measures)) {
    tbl <- tibble(outcome=eeg_measures[eeg_inds_plot]) %>%
      rowwise() %>%
      mutate(
        tbl = 
          lmer(str_glue(paste("{outcome} ~ 1 + speed_cond_num + ",kin_measures[mi]," + speed_cond_num:",kin_measures[mi]," + (1|subj_char)")), data=tmpt) %>%
          tbl_regression(tidy_fun = broom.mixed::tidy,
                         pvalue_fun = purrr::partial(style_pvalue, digits = 2),
                         intercept=TRUE) %>%
          add_global_p() %>%
          add_q() %>%
          list()
        ) %>%
      pull(tbl) %>% 
      tbl_merge(tab_spanner=eeg_title_chars[eeg_inds_plot])
    
    t_out <- as_gt(tbl) %>%
      gt::tab_header(title=c("Changes in ",kin_measures[mi],"for Cluster: ",ci)) %>%
      gt::tab_options(table.layout = "fixed") %>%
      gt::as_raw_html()
    print(t_out)
    
    rsq <- tibble(outcome=eeg_measures[eeg_inds_plot]) %>%
    rowwise() %>%
    mutate(
        mod = 
          lmer(str_glue(paste("{outcome} ~ 1 + speed_cond_num + ",kin_measures[mi]," + speed_cond_num:",kin_measures[mi]," + (1|subj_char)")), data=tmpt) %>%
          r.squaredGLMM(),
          print(str_glue("{outcome}\n R2m: {round(mod[1],4)},\tR2c: {round(mod[2],4)}\n\n"))
    )
    
    #%% VISUALIZATION OF MODELS
    theme_set(theme_classic()) # This sets the default ggplot theme
    fitfit <- tibble(outcome=eeg_measures[eeg_inds_plot]) %>%
      rowwise() %>%
      mutate(
          mod = 
            lmer(str_glue(paste("{outcome} ~ 1 + speed_cond_num + ",kin_measures[mi]," + speed_cond_num:",kin_measures[mi]," + (1|subj_char)")), data=tmpt)%>%
            list()
      )
    # color_pal_subj = as.vector(createPalette(length(levels(tmpt$subj_char)),c("#4f4f4f","#5f5f5f")));
    
    for(modi in 1:length(eeg_measures[eeg_inds_plot])){
      eegi = eeg_inds_plot[modi]
      tmpt <- tmpt %>%
        mutate(fit.m = predict(fitfit$mod[[modi]], re.form = NA),
               fit.c = predict(fitfit$mod[[modi]], re.form = NULL))
      print(plot_model(fitfit$mod[[modi]], type = 'diag'))
      #%% PLOTLY IMPLEMENT
      xc = "speed_cond_num";
      yc = kin_measures[mi];
      xyc = paste0("speed_cond_num:",kin_measures[mi])
      coefs <- fixef(fitfit$mod[[modi]])
      ran_effs <- ranef(fitfit$mod[[modi]])$subj_char
      #- initiate plot_ly
      plot_obj <- plot_ly()
      #%% PLOT MAIN EFFECTS
      grid_lines <- seq(min(tmpt[[xc]]), max(tmpt[[xc]]), length.out = 10)
      grid_y <- seq(min(tmpt[[yc]]), max(tmpt[[yc]]), length.out = 10)
      # Calculate plane parameters for this group
      a <- coefs[xc] + coefs[xyc] * mean(tmpt[[yc]])
      b <- coefs[yc] + coefs[xyc] * mean(tmpt[[xc]])
      d <- coefs["(Intercept)"] + coefs[xyc] * mean(tmpt[[xc]]) * mean(tmpt[[yc]])
      # Create the plane's z-values using the equation of the plane
      plane_z <- outer(grid_lines, grid_y, function(x, y) a * x + b * y + d)
      # Add the plane
      plot_obj <- plot_obj %>% add_trace(x = ~grid_lines,
                             y = ~grid_y,
                             z = ~plane_z,
                             type = "surface",
                             opacity = 0.5,
                             showscale = FALSE,
                             name = "Fixed Effect Fit")
      #- new implementation
      # plot_obj <- plot_obj %>% add_trace(x = tmpt[[xc]],
      #                                    y = tmpt[[yc]],
      #                                    z = tmpt$fit.c, #tmpt[[eeg_measures[eegi]]],
      #                                    split = tmpt$subj_char,
      #                                    # colors = "gray",
      #                                    opacity = 0.75,
      #                                    # showscale = FALSE,
      #                                    type='scatter3d',
      #                                    mode ='lines',
      #                                    line=list(color="black",dash='solid',width=10))
      # print(plot_obj)
      #%% ADD SCATTER
      plot_obj <- plot_obj %>% add_trace(x = tmpt[[xc]],
                                         y = tmpt[[yc]], 
                                         z = tmpt[[eeg_measures[eegi]]],
                                         color = tmpt$group_char,
                                         colors = color_pal_group,
                                         opacity=0.75,
                                         # color = tmpt$group_char,
                                         # colors = heat.colors(length(levels(tmpt$group_char))),
                                         type = "scatter3d",
                                         mode = "markers")
      # Finalize the layout
      plot_obj <- plot_obj %>% layout(title = paste(ci,")",eeg_measures[eegi],",",kin_measures[mi]),
                                     scene = list(xaxis = list(title = x_vals_labs, ticktype = "array"),
                                                  yaxis = list(title = kin_title_chars[mi], ticktype = "array"),
                                                  zaxis = list(title = eeg_title_chars[eegi], ticktype = "array"),
                                                  camera = list(eye = list(x = 1.5, y = -1.5, z = 1), zoom = 2.5),
                                                  showlegend = FALSE))
      
      #%% SAVE WIDGET AS AN INDEPENDENT HTML FILE
      pwd <- getwd()
      widg_path = paste0("/widgets/",ci,"_",eeg_measures[eegi],"_",kin_measures[mi],".html");
      # widg_path = paste0(pwd,"/widgets/",ci,"_",eeg_measures[eegi],"_",kin_measures[mi],".html");
      dir.create(file.path(pwd,'widgets'))
      #%% EMBED HTML WIDGET (THIS IS A ROBUST WAY TO SAVE WIDGET SO IT WORKS)
      # htmlwidgets::saveWidget(plot_obj, widg_path)
      
      # Embed external HTML in the document
      
      #%% THESE DID NOT WORK
      #-
      # app_urls[[cnt]] <- widg_path;
      #-
      # cat('<iframe src=widg_path width="100%" height="400px" scrolling="no" seamless="seamless"></iframe>')
      #-
      # b64 <- base64enc::dataURI(file = widg_path, mime = "text/html")
      # l[[cnt]] <- tagList(HTML(markdown::mark(text=paste0("\n\n### ", cnt, "\n"))),renderUI({
      #   htmltools::tags$iframe(src=b64,  height=600, width="100%")
      # }))
      #-
      # l[[cnt]] <- tagList(HTML(markdown::mark(text=paste0("\n\n### ", cnt, "\n"))),htmltools::tags$iframe(
      #   src=widg_path,
      #   width="100%",
      #   height="400",
      #   scrolling="no",
      #   seamless="seamless",
      #   frameBorder="0"
      # ))
      #-
      # knit_print.shiny.tag(ggplotly(plot_obj, width = 480, height = 320))
      # l[[cnt]] <- tagList(HTML(markdown::mark(text=paste0("\n\n### ", cnt, "\n"))),()) # This works.
      # cnt = cnt + 1;
      #-
      # l[[cnt]] <- tagList(HTML(markdown::mark(text=paste0("\n\n### ", cnt, "\n"))),plotly:::plotly_iframe(plot_obj))
      #%% THIS KIND OF WORKS (DOESN'T LOAD ALL WIDGETS (>16-ish))
      l[[cnt]] <- tagList(HTML(markdown::mark(text=paste0("\n\n### ", cnt, "\n"))), ggplotly(plot_obj, width = 480, height = 320))
      cnt = cnt + 1;
      cat("\n")
    }
  }
}
```
## PLOTLY PLOTS
```{r results='asis'}
l
# htmltools::tagList(l)
```
<!-- # MODERATION 1.b) LME EEG ~ 1+kin+speed+kin:speed -->

<!-- ```{r eegkinspeed, echo=FALSE, message=FALSE, results="asis"} -->
<!-- suppressWarnings({ -->
<!--   suppressMessages({ -->
<!-- library(plotly) -->
<!-- library(htmltools) -->
<!--     })}) -->
<!-- l <- htmltools::tagList() -->
<!-- cnt = 1 -->
<!-- # library(scatterplot3d) -->
<!-- for (ci in cluster_inds_plot) { -->
<!--   tmpt <- filter_at(eegt,vars('cluster_id'), any_vars(. %in% ci)); -->
<!--   for(ki in kin_inds_plot){ -->
<!--     tmpt = tmpt[complete.cases(tmpt[[kin_measures[ki]]]),] -->
<!--   } -->
<!--   for (mi in 1:length(kin_measures)) { -->
<!--     tbl <- tibble(outcome=eeg_measures[eeg_inds_plot]) %>% -->
<!--       rowwise() %>% -->
<!--       mutate( -->
<!--         tbl =  -->
<!--           lmer(str_glue(paste("{outcome} ~ 1 + speed_cond_num + ",kin_measures[mi]," + (1|subj_char)")), data=tmpt) %>% -->
<!--           tbl_regression(tidy_fun = broom.mixed::tidy, -->
<!--                          pvalue_fun = purrr::partial(style_pvalue, digits = 2), -->
<!--                          intercept=TRUE) %>% -->
<!--           add_global_p() %>% -->
<!--           add_q() %>% -->
<!--           list() -->
<!--         ) %>% -->
<!--       pull(tbl) %>%  -->
<!--       tbl_merge(tab_spanner=eeg_title_chars[eeg_inds_plot]) -->

<!--     t_out <- as_gt(tbl) %>% -->
<!--       gt::tab_header(title=c("Changes in ",kin_measures[mi],"for Cluster: ",ci)) %>% -->
<!--       gt::tab_options(table.layout = "fixed") %>% -->
<!--       gt::as_raw_html() -->
<!--     print(t_out) -->

<!--     rsq <- tibble(outcome=eeg_measures[eeg_inds_plot]) %>% -->
<!--     rowwise() %>% -->
<!--     mutate( -->
<!--         mod =  -->
<!--           lmer(str_glue(paste("{outcome} ~ 1 + speed_cond_num + ",kin_measures[mi]," + (1|subj_char)")), data=tmpt) %>% -->
<!--           r.squaredGLMM(), -->
<!--           print(str_glue("{outcome}\n R2m: {round(mod[1],4)},\tR2c: {round(mod[2],4)}\n\n")) -->
<!--     ) -->

<!--     #%% VISUALIZATION OF MODELS -->
<!--     theme_set(theme_classic()) # This sets the default ggplot theme -->
<!--     fitfit <- tibble(outcome=eeg_measures[eeg_inds_plot]) %>% -->
<!--       rowwise() %>% -->
<!--       mutate( -->
<!--           mod =  -->
<!--             lmer(str_glue(paste("{outcome} ~ 1 + speed_cond_num + ",kin_measures[mi]," + (1|subj_char)")), data=tmpt)%>% -->
<!--             list() -->
<!--       ) -->
<!--     # color_pal_subj = as.vector(createPalette(length(levels(tmpt$subj_char)),c("#4f4f4f","#5f5f5f"))); -->
<!--     color_pal_group = as.vector(createPalette(length(levels(tmpt$group_char)),c("#0000ff"))); -->
<!--     for(modi in 1:length(eeg_measures[eeg_inds_plot])){ -->
<!--       eegi = eeg_inds_plot[modi] -->
<!--       tmpt <- tmpt %>% -->
<!--         mutate(fit.m = predict(fitfit$mod[[modi]], re.form = NA), -->
<!--                fit.c = predict(fitfit$mod[[modi]], re.form = NULL)) -->
<!--       print(plot_model(fitfit$mod[[modi]], type = 'diag')) -->
<!--       #%% PLOTLY IMPLEMENT -->
<!--       xc = "speed_cond_num"; -->
<!--       yc = kin_measures[mi]; -->
<!--       coefs <- fixef(fitfit$mod[[modi]]) -->
<!--       ran_effs <- ranef(fitfit$mod[[modi]])$subj_char -->
<!--       #- initiate plot_ly -->
<!--       plot_obj <- plot_ly(renderTags()) -->
<!--       #%% PLOT MAIN EFFECTS -->
<!--       # # Calculate plane parameters for this group -->
<!--       grid_lines <- seq(min(tmpt[[xc]]), max(tmpt[[xc]]), length.out = 10) -->
<!--       grid_y <- seq(min(tmpt[[yc]]), max(tmpt[[yc]]), length.out = 10) -->
<!--       a <- coefs[xc] -->
<!--       b <- coefs[yc] -->
<!--       d <- coefs["(Intercept)"] -->
<!--       # Create the plane's z-values using the equation of the plane -->
<!--       plane_z <- outer(grid_lines, grid_y, function(x, y) a * x + b * y + d) -->
<!--       # Add the plane -->
<!--       plot_obj <- plot_obj %>% add_trace(x = ~grid_lines, -->
<!--                              y = ~grid_y, -->
<!--                              z = ~plane_z, -->
<!--                              type = "surface", -->
<!--                              opacity = 0.5, -->
<!--                              showscale = FALSE, -->
<!--                              name = "Fixed Effect Fit") -->
<!--       #%% PLOT RANDOM EFFECTS -->
<!--       # #- Loop over each group to add the regression planes -->
<!--       # for (g in levels(tmpt$subj_char)) { -->
<!--       #   #- Get the random effect for this group -->
<!--       #   group_effect <- ran_effs[g, "(Intercept)"] -->
<!--       #   # line_x <- seq(min(tmpt[[xc]]), max(tmpt[[xc]]), length.out = 10) -->
<!--       #   # line_y <- seq(min(tmpt[[yc]]), max(tmpt[[yc]]), length.out = 10) -->
<!--       #   tdat = subset(tmpt,subj_char==g) -->
<!--       #   line_x <- tdat[[xc]] -->
<!--       #   line_y <- tdat[[yc]] -->
<!--       #   print(line_y) -->
<!--       #   #- Calculate plane parameters for this group -->
<!--       #   a <- coefs[xc] -->
<!--       #   b <- coefs[yc] -->
<!--       #   d <- coefs["(Intercept)"] + group_effect -->
<!--       #   line_z <- coefs["(Intercept)"] + group_effect + -->
<!--       #       coefs[xc] * line_x + coefs[yc] * line_y -->
<!--       #   #- Create the plane's z-values using the equation of the plane -->
<!--       #   # plane_z <- outer(grid_lines, grid_y, function(x, y) a * x + b * y + d) -->
<!--       #   plot_obj <- plot_obj %>% add_trace(x = ~line_x, -->
<!--       #                                      y = ~line_y, -->
<!--       #                                      z = ~line_z, -->
<!--       #                                      colors = color_pal_group, -->
<!--       #                                      opacity = 0.5, -->
<!--       #                                      text = ~paste("subj.",g), -->
<!--       #                                      type='scatter3d', -->
<!--       #                                      mode ='lines', -->
<!--       #                                      line=list(dash='dash',width=5) -->
<!--       #   ) -->
<!--       # } -->
<!--       #- new implementation -->
<!--       # plot_obj <- plot_obj %>% add_trace(x = tmpt[[xc]], -->
<!--       #                                    y = tmpt[[yc]], -->
<!--       #                                    z = tmpt$fit.c, #tmpt[[eeg_measures[eegi]]], -->
<!--       #                                    split = tmpt$subj_char, -->
<!--       #                                    # colors = "gray", -->
<!--       #                                    opacity = 0.75, -->
<!--       #                                    # showscale = FALSE, -->
<!--       #                                    type='scatter3d', -->
<!--       #                                    mode ='lines', -->
<!--       #                                    line=list(color="black",dash='solid',width=10)) -->
<!--       # print(plot_obj) -->
<!--       #%% ADD SCATTER -->
<!--       plot_obj <- plot_obj %>% add_trace(x = tmpt[[xc]], -->
<!--                                          y = tmpt[[yc]],  -->
<!--                                          z = tmpt[[eeg_measures[eegi]]], -->
<!--                                          color = tmpt$group_char, -->
<!--                                          colors = color_pal_group, -->
<!--                                          opacity=0.75, -->
<!--                                          # color = tmpt$group_char, -->
<!--                                          # colors = heat.colors(length(levels(tmpt$group_char))), -->
<!--                                          type = "scatter3d", -->
<!--                                          mode = "markers") -->
<!--       # Finalize the layout -->
<!--       plot_obj <- plot_obj %>% layout(title = paste(ci,")",eeg_measures[eegi],",",kin_measures[mi]), -->
<!--                                      scene = list(xaxis = list(title = x_vals_labs, ticktype = "array"), -->
<!--                                                   yaxis = list(title = kin_title_chars[mi], ticktype = "array"), -->
<!--                                                   zaxis = list(title = eeg_title_chars[eegi], ticktype = "array"), -->
<!--                                                   camera = list(eye = list(x = 1.5, y = -1.5, z = 1), zoom = 2.5), -->
<!--                                                   showlegend = FALSE)) -->
<!--       # print(plot_obj) -->
<!--       # l[[cnt]] <- plot_obj; -->
<!--       plot_obj <- toWebGL(ggplotly(plot_obj, width = 720, height = 480)) -->
<!--       l[[cnt]] <- tagList(HTML(markdown::mark(text=paste0("\n\n#### ", cnt, "\n"))), ) -->
<!--       cnt = cnt + 1; -->
<!--       #  -->
<!--       # plot_obj -->
<!--       # ggplotly(plot_obj, width = 672, height = 480) -->
<!--       # knit_print(ggplotly(plot_obj, width = 672, height = 480)) -->
<!--       # cat(knit_print(ggplotly(plot_obj, width = 672, height = 480))) # This works. -->
<!--       cat("\n") -->
<!--     } -->
<!--   } -->
<!-- } -->
<!-- ``` -->
<!-- ## PLOTLY PLOTS -->
<!-- ```{r results='asis'} -->
<!-- l -->
<!-- # htmltools::tagList(l) -->
<!-- ``` -->
