---
title: "Linear Mixed Effects Models for Kin & Speed Predictors for EEG"
author: "Jacob Salminen"
date: \`r format(Sys.Date(),"%d-%m-%Y")`\
output:
  html_document:
    theme: flatly
    toc: true
    toc_depth: 6
    toc_float:
      collapsed: true
      smooth_scroll: true
    df_print: paged
---

```{r setup, include=FALSE}
# ERROR. png() device not found bug try: dev.off()
# ERROR. png() device not found fixed by changing cell names to a simple "windows friendlY" format so that knitr could save files.
knitr::opts_chunk$set(echo = TRUE)
```

# Packages & Setup
```{r}
# install.packages(c("tidyverse","purrr","R.matlab","readxl","dplyr"))
library(readxl);
library(purrr);
library(tidyverse);
library(tibble);
library(knitr);
library(gtsummary);
library(kableExtra);
library(lme4);
library(MuMIn);
# library(effects);
library(sjPlot);
library(plotly);
library(webshot)
library(reshape2);
library(htmltools)
library(Polychrome);
library(htmlwidgets);
library(shiny)
library(webshot)
```

## GTSUMMARY THEME
``` {r}
# my_theme <-
#   list(
#     "tbl_summary-str:default_con_type" = "continuous2",
#     "tbl_summary-str:continuous_stat" = c(
#       "{median} ({p25} - {p75})",
#       "{mean} ({sd})",
#       "{min} - {max}"
#     ),
#     "tbl_summary-str:categorical_stat" = "{n} / {N} ({p}%)",
#     "style_number-arg:big.mark" = "",
#     "tbl_summary-fn:percent_fun" = function(x) style_percent(x, digits = 3)
#   )
# my_theme <-
#   list()
# gtsummary::set_gtsummary_theme(my_theme)
gtsummary::set_gtsummary_theme(theme_gtsummary_journal("jama"))
# reset_gtsummary_theme()
```

# load table 
```{r} 
# excel_dir <-"M:/jsalminen/GitHub/par_EEGProcessing/src/_data/MIM_dataset/_studies/04162024_MIM_YAOAN89_antsnormalize_iccREMG0p4_powpow0p3_skull0p01/cluster/icrej_5/12/spec_data/group_spec/psd_calcs/fooof_kinematics_table.xlsx";
# excel_dir <-"M:/jsalminen/GitHub/par_EEGProcessing/src/_data/MIM_dataset/_studies/04232024_MIM_YAOAN89_antsnorm_dipfix_iccREMG0p4_powpow0p3_skull0p01_15mmrej/cluster/icrej_5/11/spec_data/group_spec/psd_calcs/fooof_kinematics_table_nans.xlsx";
excel_dir <-"M:/jsalminen/GitHub/par_EEGProcessing/src/_data/MIM_dataset/_studies/04232024_MIM_YAOAN89_antsnorm_dipfix_iccREMG0p4_powpow0p3_skull0p01_15mmrej/iclabel_cluster_kmeansalt_rb3/icrej_5/11/psd_calcs/group_spec/kin_tests/fooof_kinematics_table.xlsx";
orig_eegt <- read_excel(excel_dir,sheet="Sheet1") 
```

## get unique entries 
```{r} 

#%% KIN PARAMS
# kin_measures = c('mean_APexc_COV','mean_APexc_mean','mean_MLexc_COV','mean_MLexc_mean','mean_StepDur','mean_StepDur_cov','mean_UDexc_COV','mean_UDexc_mean','mean_StanceDur','mean_GaitCycleDur','mean_PeakUpDownVel_mean');
# kin_title_chars = c("AP Exc. COV","AP Exc. Mean","ML Exc. COV","ML Exc. Mean","Step Dur.","Step Dur. COV","UD Exc. COV","UD Exc Mean","Stance Dur.","Gait Cycle Dur.","Peak UD Vel. Mean")
# kin_measures = c('mean_APexc_COV','mean_MLexc_COV','mean_StepDur_cov','mean_StanceDur');
# kin_title_chars = c("AP Exc. COV","ML Exc. COV","Step Dur. COV","Stance Dur.")
kin_measures = c('mean_APexc_COV');
kin_title_chars = c("AP Exc. COV")
kin_inds_plot = c(1:length(kin_measures));
# kin_inds_plot = c(1,3,6,5,7);
#%% EEG PARAMS
clusters = unique(orig_eegt$cluster_id);
subjects = unique(orig_eegt$subj_char);
groups = unique(orig_eegt$group_char);
# eeg_measures = c('theta_avg_power','alpha_avg_power','beta_avg_power','beta_div_theta','theta_div_beta','log_beta_div_theta','log_theta_div_beta','aperiodic_exp','aperiodic_offset');
# eeg_title_chars = c("**THETA**","**ALPHA**","**BETA**","**BETA/THETA**","**THETA/BETA**","**log10(BETA/THETA)**","**log10(THETA/BETA)**","**AP exp**","**AP offset**");
# eeg_measures = c('theta_avg_power','alpha_avg_power','beta_avg_power','aperiodic_exp','aperiodic_offset');
eeg_measures = c('norm_theta_avg_power','norm_alpha_avg_power','norm_beta_avg_power');
eeg_title_chars = c("**THETA**","**ALPHA**","**BETA**");
# eeg_inds_plot = c(1:length(eeg_title_chars));
eeg_inds_plot = c(1,2,3);
# x_vals_plot = c('speed_diffdiv_stat')
# x_vals_labs = c("**{DELTA Speed}/{Subj. Speed}**")
# x_vals_plot = 'speed_diff_stat'
# x_vals_labs = c("Trial_vel-Subj_vel/(Subj_vel)**")
x_vals_plot = c('speed_div_stat')
x_vals_labs = c("**{Trial_vel/Subj_vel}**")
# cluster_inds_plot = c(3,4,5,6,7,8,12);
cluster_inds_plot = c(3,4,5);
```

## create ratios
```{r}
df <- orig_eegt %>%
  select(subj_char,cond_char,cluster_id,group_id,alpha_avg_power,beta_avg_power,theta_avg_power) %>%
  pivot_wider(names_from = "cond_char", names_sep = '.', values_from = c(alpha_avg_power,beta_avg_power,theta_avg_power))

# df <- df %>%
#   group_by(subj_char) %>%
#   mutate(across(starts_with("alpha_avg_power"), ~ .x/alpha_avg_power.flat))
# df <- df %>%
#   group_by(subj_char) %>%
#   mutate(across(starts_with("beta_avg_power"), ~ .x/beta_avg_power.flat))
# df <- df %>%
#   group_by(subj_char) %>%
#   mutate(across(starts_with("theta_avg_power"), ~ .x/theta_avg_power.flat))
df <- df %>%
  group_by(subj_char) %>%
  mutate(across(starts_with("alpha_avg_power"), ~ .x-alpha_avg_power.flat))
df <- df %>%
  group_by(subj_char) %>%
  mutate(across(starts_with("beta_avg_power"), ~ .x-beta_avg_power.flat))
df <- df %>%
  group_by(subj_char) %>%
  mutate(across(starts_with("theta_avg_power"), ~ .x-theta_avg_power.flat))

df <- df %>%
  pivot_longer(cols = starts_with(c("alpha","beta","theta")), names_to = c(".value","cond_char"), names_pattern = "(.*_power).(.*)");

df$norm_alpha_avg_power <- df$alpha_avg_power
df$norm_beta_avg_power <- df$beta_avg_power
df$norm_theta_avg_power <- df$theta_avg_power
df <- select(df,-alpha_avg_power,-beta_avg_power,-theta_avg_power);
eegt <- merge(orig_eegt , df, by.x = c("subj_char","cond_char","cluster_id","group_id"), by.y = c("subj_char","cond_char","cluster_id","group_id"));
# kin_measures = c('mean_APexc_COV','mean_MLexc_COV','mean_StepDur_COV','mean_StanceDur');
eegt <- eegt %>%
  select(subj_char,cond_char,group_char,cluster_id,group_id,norm_alpha_avg_power,norm_theta_avg_power,norm_beta_avg_power,alpha_avg_power,beta_avg_power,theta_avg_power,mean_APexc_COV,mean_MLexc_COV,mean_StepDur_cov,mean_StanceDur,speed_div_stat,speed_diff_stat,speed_diffdiv_stat,speed_ms);
eegt$x_vals_plot = eegt[[x_vals_plot]];
```
## get speeds only 
```{r}
# eegt <- filter_at(eegt,vars('cond_char'), any_vars(. %in% c('0.25','0.5','0.75','1.0')))
eegt <- filter_at(eegt,vars('cond_char'), any_vars(. %in% c('flat','0.25','0.5','0.75','1.0')))
#%% SPEED_DIFF_STAT
# eegt <- eegt %>%
#   mutate(x_vals_plot = ifelse(cond_char == "flat", 0, x_vals_plot)) #as.character(speed_ms)
# eegt <- eegt %>%
#   mutate(cond_char = ifelse(cond_char == "flat", as.character(0), cond_char)) #as.character(speed_ms)
#%% SPEED_DIV_STAT
# eegt <- eegt %>%
#   mutate(x_vals_plot = ifelse(cond_char == "flat", 1, x_vals_plot)) #as.character(speed_ms)
# eegt <- eegt %>%
#   mutate(cond_char = ifelse(cond_char == "flat", as.character(1), cond_char)) #as.character(speed_ms)
#%% COND_CHAR
eegt <- eegt %>%
  mutate(cond_char = ifelse(cond_char == "flat", speed_ms, cond_char)) #as.character(speed_ms)
#%%
flat_speeds = unique(eegt$cond_char)
# eegt$speed_cond_num <- as.numeric(eegt$x_vals_plot);
eegt$speed_cond_num <- as.numeric(eegt$cond_char);
eegt <- mutate(eegt,across(c('subj_char'), factor))
eegt <- mutate(eegt,across(c('group_char'), factor))
color_pal_group = as.vector(createPalette(length(levels(eegt$group_char)),c("#0000ff")));
head(eegt)
```

```{r}
# Custom knit_print method for api_plot objects
knit_print.plotly <- function(x, ...) {
  # Create a temporary HTML file to store the Plotly plot
  temp_file <- tempfile(fileext = ".html")
  
  # Save the Plotly plot as a self-contained HTML file
  htmlwidgets::saveWidget(x, temp_file, selfcontained = TRUE)
  
  # Embed the plot using an iframe
  iframe_html <- sprintf('<iframe src="%s" width="100%%" height="600" frameborder="0"></iframe>', temp_file)
  
  # Return iframe HTML to knitr as raw HTML output
  knitr::asis_output(iframe_html)
}
```
# MODERATION 1) LME EEG ~ 1+speed+kin+speed:kin
```{r eegspeedkininter, echo=FALSE, message=FALSE, results="asis"}
# apply_eeg_mod <- function(tbl,mod_char) {
#   lmer(str_glue(mod_char), data=tbl) %>%
# }
for (ci in cluster_inds_plot) {
  tmptc <- filter_at(eegt,vars('cluster_id'), any_vars(. %in% ci));
  for(ki in kin_inds_plot){
    tmptc = tmptc[complete.cases(tmptc[[kin_measures[ki]]]),]
  }
  for(ki in kin_inds_plot){
    for (gi in 1:length(groups)) {
      tmpt <- filter_at(tmptc,vars('group_char'), any_vars(. %in% groups[gi]));
      mod_char = paste("{outcome} ~ 1 + speed_cond_num + ",kin_measures[ki]," + speed_cond_num:",kin_measures[ki]," + (1|subj_char)");
      tbl <- tibble(outcome=eeg_measures[eeg_inds_plot]) %>%
        rowwise() %>%
        mutate(
          tbl = 
            lmer(str_glue(mod_char), data=tmpt) %>%
            tbl_regression(tidy_fun = broom.mixed::tidy,
                           pvalue_fun = purrr::partial(style_pvalue, digits = 2),
                           intercept=TRUE) %>%
            add_global_p(anova_fun = car::Anova) %>%
            list()
          ) %>%
        pull(tbl) %>% 
        tbl_merge(tab_spanner=eeg_title_chars[eeg_inds_plot])
      
      
      # anova_out = car::Anova(tbl,type=3);
      #- HTML TAG
      # print(htmltools:tags(HTML(markdown::mark(text=paste0("\n\n### ", ci,",", ki, "\n")))))
      cat(paste0("\n\n### ", ci,",",groups[gi],",", kin_measures[ki], "\n"))
      #%% PRINT TABLE
      t_out <- as_gt(tbl) %>%
        gt::tab_header(title=c("Changes in ",kin_measures[ki],"for Cluster: ",ci)) %>%
        gt::tab_options(table.layout = "fixed") %>%
        gt::as_raw_html()
      print(t_out)
      
      rsq <- tibble(outcome=eeg_measures[eeg_inds_plot]) %>%
      rowwise() %>%
      mutate(
          mod = 
            lmer(str_glue(mod_char), data=tmpt) %>%
            r.squaredGLMM(),
            print(str_glue("{outcome}\n R2m: {round(mod[1],4)},\tR2c: {round(mod[2],4)}\n\n"))
      )
      
      #%% VISUALIZATION OF MODELS
      theme_set(theme_classic()) # This sets the default ggplot theme
      fitfit <- tibble(outcome=eeg_measures[eeg_inds_plot]) %>%
        rowwise() %>%
        mutate(
            mod = 
              lmer(str_glue(mod_char), data=tmpt)%>%
              list()
        )
      # color_pal_subj = as.vector(createPalette(length(levels(tmpt$subj_char)),c("#4f4f4f","#5f5f5f")));
      
      for(modi in 1:length(eeg_measures[eeg_inds_plot])){
        eegi = eeg_inds_plot[modi]
        #%% MODEL VALIDATIONS
        cat(paste0("\n\n#### ",eeg_title_chars[modi],"model validations\n"))
        tmpt <- tmpt %>%
          mutate(fit.m = predict(fitfit$mod[[modi]], re.form = NA),
                 fit.c = predict(fitfit$mod[[modi]], re.form = NULL))
        print(plot_model(fitfit$mod[[modi]], type = 'diag'))
        cat("\n")
        #%% SAVE WIDGET AS AN INDEPENDENT HTML FILE
        pwd <- getwd()
        widg_fname = paste0(ci,"_",gi,"_",eeg_measures[eegi],"_",kin_measures[ki],"_inter.html");
        widg_path = file.path(pwd,'widgets',widg_fname);
        dir.create(file.path(pwd,'widgets'))
        #%% PLOTLY IMPLEMENT
        cat(paste0("\n\n#### ",eeg_title_chars[modi],"plot\n"))
        xc = "speed_cond_num";
        yc = kin_measures[ki];
        xyc = paste0("speed_cond_num:",kin_measures[ki])
        coefs <- fixef(fitfit$mod[[modi]])
        ran_effs <- ranef(fitfit$mod[[modi]])$subj_char
        #- initiate plot_ly
        plot_obj <- plot_ly(filename=widg_path)
        plot_obj <- plot_ly()
        #%% PLOT MAIN EFFECTS
        grid_lines <- seq(min(tmpt[[xc]]), max(tmpt[[xc]]), length.out = 10)
        grid_y <- seq(min(tmpt[[yc]]), max(tmpt[[yc]]), length.out = 10)
        # Calculate plane parameters for this group
        a <- coefs[xc] + coefs[xyc] * mean(tmpt[[yc]])
        b <- coefs[yc] + coefs[xyc] * mean(tmpt[[xc]])
        d <- coefs["(Intercept)"] + coefs[xyc] * mean(tmpt[[xc]]) * mean(tmpt[[yc]])
        # Create the plane's z-values using the equation of the plane
        plane_z <- outer(grid_lines, grid_y, function(x, y) a * x + b * y + d)
        # Add the plane
        plot_obj <- plot_obj %>% add_trace(x = ~grid_lines,
                               y = ~grid_y,
                               z = ~plane_z,
                               type = "surface",
                               opacity = 0.5,
                               showscale = FALSE,
                               name = "Fixed Effect Fit")
        #%% ADD SCATTER
        plot_obj <- plot_obj %>% add_trace(x = tmpt[[xc]],
                                           y = tmpt[[yc]], 
                                           z = tmpt[[eeg_measures[eegi]]],
                                           color = tmpt$group_char,
                                           colors = color_pal_group,
                                           opacity=0.75,
                                           # color = tmpt$group_char,
                                           # colors = heat.colors(length(levels(tmpt$group_char))),
                                           type = "scatter3d",
                                           mode = "markers")
        # Finalize the layout
        plot_obj <- plot_obj %>% layout(title = paste(ci,")",eeg_measures[eegi],",",kin_measures[ki]),
                                       scene = list(xaxis = list(title = x_vals_labs, ticktype = "array"),
                                                    yaxis = list(title = kin_title_chars[ki], ticktype = "array"),
                                                    zaxis = list(title = eeg_title_chars[eegi], ticktype = "array"),
                                                    camera = list(eye = list(x = 1.5, y = -1.5, z = 1), zoom = 2.5),
                                                    showlegend = FALSE))
        # print(ggplotly(plot_obj,width = 680, height = 480));
        # cat(knit_print(ggplotly(plot_obj,width = 720, height = 480)))
        # export(ggplot)
        
        #%% EMBED HTML WIDGET (THIS IS A ROBUST WAY TO SAVE WIDGET SO IT WORKS)
        # htmlwidgets::saveWidget(ggplotly(plot_obj,width = 720, height = 480), widg_path, selfcontained = FALSE)
        # htmlwidgets::saveWidget(plot_obj, widg_path, selfcontained = FALSE)
        # # Display the iframe HTML
        # cat('<iframe', paste0('src=',file.path('/widgets', widg_fname),' width="100%" height="500px" frameborder="0"></iframe>'));
        # knit_print.plotly(plot_obj)
        # knit_print.api_plot(plot_obj,options=NULL)
        # Embed external HTML in the document
        #%% THIS KIND OF WORKS (DOESN'T LOAD ALL WIDGETS (>16-ish))
        l[[cnt]] <- tagList(HTML(markdown::mark(text=cat(paste0("\n\n#### ",eeg_title_chars[modi],"plot\n")))), ggplotly(plot_obj, width = 480, height = 320))
        # cnt = cnt + 1;
        cat("\n")
      }
    }
  } 
}
```
## PLOTLY PLOTS
```{r results='asis'}
l
# htmltools::tagList(l)
```

# MODERATION 2) LME EEG ~ 1+speed+kin
```{r eegspeedk, echo=FALSE, message=FALSE, results="asis"}
for (ci in cluster_inds_plot) {
  tmptc <- filter_at(eegt,vars('cluster_id'), any_vars(. %in% ci));
  for(ki in kin_inds_plot){
    tmptc = tmptc[complete.cases(tmptc[[kin_measures[ki]]]),]
  }
  for(ki in kin_inds_plot){
    for (gi in 1:length(groups)) {
      tmpt <- filter_at(tmptc,vars('group_char'), any_vars(. %in% groups[gi]));
      mod_char = paste("{outcome} ~ 1 + speed_cond_num + ",kin_measures[ki]," + (1|subj_char)");
      tbl <- tibble(outcome=eeg_measures[eeg_inds_plot]) %>%
        rowwise() %>%
        mutate(
          tbl =
            lmer(str_glue(mod_char), data=tmpt) %>%
            tbl_regression(tidy_fun = broom.mixed::tidy,
                           pvalue_fun = purrr::partial(style_pvalue, digits = 2),
                           intercept=TRUE) %>%
            add_global_p() %>%
            add_q() %>%
            list()
          ) %>%
        pull(tbl) %>%
        tbl_merge(tab_spanner=eeg_title_chars[eeg_inds_plot])

      #- HTML TAG
      # print(htmltools:tags(HTML(markdown::mark(text=paste0("\n\n### ", ci,",", ki, "\n")))))
      cat(paste0("\n\n### ", ci,",",groups[gi],",", kin_measures[ki], "\n"))
      #%% PRINT TABLE
      t_out <- as_gt(tbl) %>%
        gt::tab_header(title=c("Changes in ",kin_measures[ki],"for Cluster: ",ci)) %>%
        gt::tab_options(table.layout = "fixed") %>%
        gt::as_raw_html()
      print(t_out)

      rsq <- tibble(outcome=eeg_measures[eeg_inds_plot]) %>%
      rowwise() %>%
      mutate(
          mod =
            lmer(str_glue(mod_char), data=tmpt) %>%
            r.squaredGLMM(),
            print(str_glue("{outcome}\n R2m: {round(mod[1],4)},\tR2c: {round(mod[2],4)}\n\n"))
      )

      #%% VISUALIZATION OF MODELS
      theme_set(theme_classic()) # This sets the default ggplot theme
      fitfit <- tibble(outcome=eeg_measures[eeg_inds_plot]) %>%
        rowwise() %>%
        mutate(
            mod =
              lmer(str_glue(mod_char), data=tmpt)%>%
              list()
        )
      # color_pal_subj = as.vector(createPalette(length(levels(tmpt$subj_char)),c("#4f4f4f","#5f5f5f")));

      for(modi in 1:length(eeg_measures[eeg_inds_plot])){
        eegi = eeg_inds_plot[modi]
        #%% MODEL VALIDATIONS
        cat(paste0("\n\n#### ",eeg_title_chars[modi],"model validations\n"))
        tmpt <- tmpt %>%
          mutate(fit.m = predict(fitfit$mod[[modi]], re.form = NA),
                 fit.c = predict(fitfit$mod[[modi]], re.form = NULL))
        print(plot_model(fitfit$mod[[modi]], type = 'diag'))
        cat("\n")
        cat(paste0("\n\n#### ",eeg_title_chars[modi],"plot\n"))
        #%% SAVE WIDGET AS AN INDEPENDENT HTML FILE
        pwd <- getwd()
        widg_path = file.path(pwd,'widgets',paste0(ci,"_",gi,"_",eeg_measures[eegi],"_",kin_measures[ki],"_mains.html"));
        dir.create(file.path(pwd,'widgets'))
        #%% PLOTLY IMPLEMENT
        xc = "speed_cond_num";
        yc = kin_measures[ki];
        coefs <- fixef(fitfit$mod[[modi]])
        ran_effs <- ranef(fitfit$mod[[modi]])$subj_char
        #- initiate plot_ly
        plot_obj <- plot_ly(filename=widg_path)
        #%% PLOT MAIN EFFECTS
        # # Calculate plane parameters for this group
        grid_lines <- seq(min(tmpt[[xc]]), max(tmpt[[xc]]), length.out = 10)
        grid_y <- seq(min(tmpt[[yc]]), max(tmpt[[yc]]), length.out = 10)
        a <- coefs[xc]
        b <- coefs[yc]
        d <- coefs["(Intercept)"]
        # Create the plane's z-values using the equation of the plane
        plane_z <- outer(grid_lines, grid_y, function(x, y) a * x + b * y + d)
        # Add the plane
        plot_obj <- plot_obj %>% add_trace(x = ~grid_lines,
                               y = ~grid_y,
                               z = ~plane_z,
                               type = "surface",
                               opacity = 0.5,
                               showscale = FALSE,
                               name = "Fixed Effect Fit")
        #%% PLOT RANDOM EFFECTS
        #- Loop over each group to add the regression planes
        for (g in levels(tmpt$subj_char)) {
          #- Get the random effect for this group
          group_effect <- ran_effs[g, "(Intercept)"]
          # line_x <- seq(min(tmpt[[xc]]), max(tmpt[[xc]]), length.out = 10)
          # line_y <- seq(min(tmpt[[yc]]), max(tmpt[[yc]]), length.out = 10)
          tdat = subset(tmpt,subj_char==g)
          line_x <- tdat[[xc]]
          line_y <- tdat[[yc]]
          print(line_y)
          #- Calculate plane parameters for this group
          a <- coefs[xc]
          b <- coefs[yc]
          d <- coefs["(Intercept)"] + group_effect
          line_z <- coefs["(Intercept)"] + group_effect +
              coefs[xc] * line_x + coefs[yc] * line_y
          #- Create the plane's z-values using the equation of the plane
          # plane_z <- outer(grid_lines, grid_y, function(x, y) a * x + b * y + d)
          plot_obj <- plot_obj %>% add_trace(x = ~line_x,
                                             y = ~line_y,
                                             z = ~line_z,
                                             colors = color_pal_group,
                                             opacity = 0.5,
                                             text = ~paste("subj.",g),
                                             type='scatter3d',
                                             mode ='lines',
                                             line=list(dash='dash',width=5)
          )
        }
        #%% ADD SCATTER
        plot_obj <- plot_obj %>% add_trace(x = tmpt[[xc]],
                                           y = tmpt[[yc]],
                                           z = tmpt[[eeg_measures[eegi]]],
                                           color = tmpt$group_char,
                                           colors = color_pal_group,
                                           opacity=0.75,
                                           # color = tmpt$group_char,
                                           # colors = heat.colors(length(levels(tmpt$group_char))),
                                           type = "scatter3d",
                                           mode = "markers")
        # Finalize the layout
        plot_obj <- plot_obj %>% layout(title = paste(ci,")",eeg_measures[eegi],",",kin_measures[ki]),
                                       scene = list(xaxis = list(title = x_vals_labs, ticktype = "array"),
                                                    yaxis = list(title = kin_title_chars[ki], ticktype = "array"),
                                                    zaxis = list(title = eeg_title_chars[eegi], ticktype = "array"),
                                                    camera = list(eye = list(x = 1.5, y = -1.5, z = 1), zoom = 2.5),
                                                    showlegend = FALSE))
        # cat(knit_print(ggplotly(plot_obj,width = 720, height = 480)))
        print(ggplotly(plot_obj,width = 680, height = 480))
        #%% EMBED HTML WIDGET (THIS IS A ROBUST WAY TO SAVE WIDGET SO IT WORKS)
        # htmlwidgets::saveWidget(plot_obj, widg_path)
        # print(plot_obj)
        # plot_obj <- toWebGL(ggplotly(plot_obj, width = 720, height = 480))
        # l[[cnt]] <- tagList(HTML(markdown::mark(text=paste0("\n\n#### ", cnt, "\n"))), )
        #%% THIS KIND OF WORKS (DOESN'T LOAD ALL WIDGETS (>16-ish))
        l[[cnt]] <- tagList(HTML(markdown::mark(text=cat(paste0("\n\n#### ",eeg_title_chars[modi],"plot\n")))), ggplotly(plot_obj, width = 480, height = 320))
        
        # cnt = cnt + 1;
        cat("\n")
      }
    }
  }
}
```
## PLOTLY PLOTS
```{r results='asis'}
l
# htmltools::tagList(l)
```


